MAX = 10**9 

def pick_min_node(distance, visited, n):
    idx, best = -1, MAX
    for v in range(1, n + 1):
        if not visited[v] and distance[v] < best:
            idx, best = v, distance[v]
    return idx

def dijkstra_seq(start, village, n):
    distance = [MAX] * (n + 1)
    visited = [False] * (n + 1)
    distance[start] = 0

    for _ in range(n):
        u = pick_min_node(distance, visited, n)
        if u == -1:
            break
        visited[u] = True

        for v, w in village[u]:
            if not visited[v] and distance[v] > distance[u] + w:
                distance[v] = distance[u] + w
    return distance

def main():
    N, M = map(int, input("노드 수 N과 간선 수 M을 입력하세요: ").split())

    village = [[] for _ in range(N + 1)]
    print(f"{M}개의 간선을 입력하세요 (a b):")
    for _ in range(M):
        a, b = map(int, input().split())
        village[a].append((b, 1))
        village[b].append((a, 1))

    X, K = map(int, input("반드시 들러야 할 노드 X와 최종 목적지 K를 입력하세요: ").split())

    d1 = dijkstra_seq(1, village, N)
    dX = dijkstra_seq(X, village, N)

    result = -1 if d1[X] >= MAX or dX[K] >= MAX else d1[X] + dX[K]
    print("결과:", result)

if __name__ == "__main__":
    main()
