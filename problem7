INF = 10**9

def pick_min_node(dist, used, n):
    """아직 확정하지 않은 노드 중 dist가 가장 작은 노드 하나 선택"""
    idx, best = -1, INF
    for v in range(1, n + 1):
        if not used[v] and dist[v] < best:
            idx, best = v, dist[v]
    return idx

def dijkstra_seq(start, graph, n):
    """우선순위큐 없이 선형으로 고르는 O(N^2) 다익스트라"""
    dist = [INF] * (n + 1)
    used = [False] * (n + 1)
    dist[start] = 0

    for _ in range(n):
        u = pick_min_node(dist, used, n)
        if u == -1:  # 더 이상 도달 가능한 노드가 없으면 끝
            break
        used[u] = True

        # u를 경유해서 이웃 v로 가는 비용이 더 짧다면 갱신
        for v, w in graph[u]:
            if not used[v] and dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
    return dist

def main():
    # 입력: N(노드 수), M(간선 수)
    N, M = map(int, input("노드 수 N과 간선 수 M을 입력하세요: ").split())

    graph = [[] for _ in range(N + 1)]
    print(f"{M}개의 간선을 입력하세요 (a b):")
    for _ in range(M):
        a, b = map(int, input().split())
        graph[a].append((b, 1))
        graph[b].append((a, 1))

    # X: 반드시 들러야 할 노드, K: 최종 목적지
    X, K = map(int, input("반드시 들러야 할 노드 X와 최종 목적지 K를 입력하세요: ").split())

    # 1 → X,  X → K 각각의 최단거리 계산
    d1 = dijkstra_seq(1, graph, N)
    dX = dijkstra_seq(X, graph, N)

    ans = -1 if d1[X] >= INF or dX[K] >= INF else d1[X] + dX[K]
    print("결과:", ans)

if __name__ == "__main__":
    main()
